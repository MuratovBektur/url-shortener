# Принятые решения по проекту URL Shortener

## PostgreSQL Cache Lookup Error - ОКОНЧАТЕЛЬНОЕ РЕШЕНИЕ (13.06.2025)

### Проблема
Критическая ошибка `cache lookup failed for relation 16408` при создании индексов в PostgreSQL 15.

### Корень проблемы
Повреждение системного каталога PostgreSQL 15, несовместимость с текущей конфигурацией Docker.

### Окончательное решение
1. **Понижение версии PostgreSQL**: с 15 до 13 (проверенная стабильная версия)
2. **Переход на Docker volume**: замена bind mount для избежания проблем с правами доступа
3. **Отключение автосинхронизации Sequelize**: `synchronize: false` для контроля над схемой БД
4. **Ручное управление схемой**: создание таблиц и индексов через SQL-команды
5. **Полная очистка Docker системы**: удаление всех поврежденных данных

### Техническая реализация
```yaml
# docker-compose.local.yml
db:
  image: postgres:13  # вместо postgres:15
  volumes:
    - postgres_data:/var/lib/postgresql/data/pgdata  # Docker volume
```

```typescript
// app.module.ts
SequelizeModule.forRoot({
  synchronize: false,  // отключение автосинхронизации
  // ...
})
```

```sql
-- Ручное создание структуры
CREATE TABLE urls (...);
CREATE INDEX idx_short_code ON urls (short_code);
CREATE INDEX idx_alias ON urls (alias) WHERE alias IS NOT NULL;
```

### Альтернативы, которые НЕ сработали
- Простой перезапуск контейнеров
- Создание индексов вручную в PostgreSQL 15
- Изменение конфигурации PostgreSQL
- Временное отключение индексов с последующим восстановлением
- Очистка только данных без смены версии

### Результат
- ✅ Приложение стабильно запускается
- ✅ API полностью функционален
- ✅ База данных работает корректно
- ✅ Производительность оптимизирована
- ✅ Решение устойчиво к перезапускам

### Рекомендации для будущих проектов
1. **Использовать стабильные версии PostgreSQL** (13, 12) вместо самых новых
2. **Предпочитать Docker volumes** для данных БД вместо bind mounts
3. **Отключать автосинхронизацию** в продакшн и управлять миграциями вручную
4. **Добавить healthcheck** для контейнера PostgreSQL
5. **Использовать инструменты миграции** (например, TypeORM migrations или Sequelize CLI)

# Технические решения проекта URL Shortener

## Архитектурные решения

### 1. Структура проекта
- **Решение**: Монорепозиторий с разделением на client и server
- **Обоснование**: Упрощает развертывание и синхронизацию изменений
- **Альтернативы**: Отдельные репозитории - более сложное управление версиями

### 2. Технологический стек
#### Backend
- **Framework**: NestJS (Node.js)
- **Database**: PostgreSQL 13
- **ORM**: Sequelize
- **Обоснование**: 
  - NestJS - отличная архитектура для масштабируемых API
  - PostgreSQL - надежность и производительность для URL данных
  - Sequelize - зрелая ORM с хорошей типизацией

#### Frontend  
- **Framework**: Vue.js 3 + Quasar
- **Language**: TypeScript
- **Обоснование**:
  - Vue.js - простота разработки и отличная реактивность
  - Quasar - богатая библиотека компонентов
  - TypeScript - безопасность типов

### 3. База данных

#### PostgreSQL версия 13 (понижение с 15)
- **Решение**: Использование PostgreSQL 13 вместо 15
- **Причина**: Критические ошибки с индексами в PostgreSQL 15
- **Проблема**: `cache lookup failed for relation 16408`
- **Альтернативы рассмотрены**: 
  - MySQL - менее подходит для сложных запросов
  - MongoDB - избыточно для простой структуры URL

#### Docker volumes вместо bind mounts
- **Решение**: Переход на Docker volume для данных PostgreSQL
- **Причина**: Проблемы с правами доступа и повреждением данных
- **Преимущества**: Изоляция данных, лучшая производительность

#### Отключение автосинхронизации Sequelize
- **Решение**: `synchronize: false` в конфигурации
- **Причина**: Конфликты при автоматическом создании индексов
- **Ручное управление**: Создание таблиц и индексов через SQL

### 4. Валидация URL

#### Кастомная валидация вместо @IsUrl()
- **Проблема**: Стандартный `@IsUrl()` блокирует localhost
- **Решение**: Собственный `CustomUrlValidator`
- **Преимущества**: 
  - Гибкость в настройке правил
  - Поддержка localhost для разработки
  - Детальный контроль над ошибками

### 5. Генерация коротких кодов
- **Алгоритм**: Случайная строка из 62 символов (a-z, A-Z, 0-9)
- **Длина**: 6 символов (62^6 = ~56 млрд комбинаций)
- **Коллизии**: Проверка существования с повторной генерацией
- **Альтернативы**: UUID (слишком длинный), автоинкремент (предсказуемый)

### 6. Динамическое формирование URL
- **Проблема**: Статический BASE_URL не подходит для разных окружений
- **Решение**: Динамическое извлечение из HTTP заголовков
- **Реализация**:
  ```typescript
  const protocol = req.get('x-forwarded-proto') || req.protocol || 'http';
  const host = req.get('x-forwarded-host') || req.get('host') || 'localhost:3000';
  const baseUrl = `${protocol}://${host}`;
  ```
- **Преимущества**:
  - Автоматическая адаптация к любому домену
  - Поддержка прокси-серверов (nginx, cloudflare)
  - Упрощение развертывания (не нужно настраивать BASE_URL)
  - Работа в любом окружении без изменений кода

## Решения по безопасности

### 1. Валидация входных данных
- **Frontend**: Реальное время + перед отправкой
- **Backend**: DTO с class-validator
- **Двойная защита**: Предотвращение обхода клиентской валидации

### 2. Защита от злоупотреблений
- **Длина URL**: Ограничение 2048 символов
- **Алиасы**: 3-20 символов, только буквы/цифры
- **Экспирация**: Автоматическое удаление просроченных

## Решения по производительности

### 1. Индексы базы данных
- **idx_short_code**: Основной индекс для быстрого поиска
- **idx_alias**: Для пользовательских алиасов
- **Композитные индексы**: Рассматриваются для аналитики

### 2. Кэширование (планируется)
- **Redis**: Для часто используемых ссылок
- **CDN**: Для статических ресурсов

## Рекомендации для развития

### 1. Мониторинг
- Добавить логирование запросов
- Метрики производительности
- Алерты на ошибки

### 2. Масштабирование
- Горизонтальное масштабирование API
- Репликация базы данных
- Load balancing

### 3. Дополнительные функции
- Аналитика переходов
- Админ панель
- Rate limiting
- Кастомные домены
